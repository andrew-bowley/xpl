/* Generated By:JavaCC: Do not edit this line. QueryParser.java */
package au.com.cybersearch2.classy_logic.parser;

import java.io.InputStream;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;
import java.util.HashMap;

import au.com.cybersearch2.classy_logic.Scope;
import au.com.cybersearch2.classy_logic.pattern.KeyName;
import au.com.cybersearch2.classy_logic.pattern.Template;
import au.com.cybersearch2.classy_logic.pattern.Choice;
import au.com.cybersearch2.classy_logic.query.QuerySpec;
import au.com.cybersearch2.classy_logic.query.QueryType;
import au.com.cybersearch2.classy_logic.QueryProgram;
import au.com.cybersearch2.classy_logic.compile.ParserAssembler;
import au.com.cybersearch2.classy_logic.compile.ParserResources;
import au.com.cybersearch2.classy_logic.compile.Group;
import au.com.cybersearch2.classy_logic.compile.OperandMap;
import au.com.cybersearch2.classy_logic.compile.OperandType;
import au.com.cybersearch2.classy_logic.compile.VariableType;
import au.com.cybersearch2.classy_logic.expression.BigDecimalOperand;
import au.com.cybersearch2.classy_logic.expression.BooleanOperand;
import au.com.cybersearch2.classy_logic.expression.DoubleOperand;
import au.com.cybersearch2.classy_logic.expression.StringOperand;
import au.com.cybersearch2.classy_logic.expression.NullOperand;
import au.com.cybersearch2.classy_logic.expression.IntegerOperand;
import au.com.cybersearch2.classy_logic.expression.RegExOperand;
import au.com.cybersearch2.classy_logic.expression.MatchOperand;
import au.com.cybersearch2.classy_logic.expression.Evaluator;
import au.com.cybersearch2.classy_logic.expression.LoopEvaluator;
import au.com.cybersearch2.classy_logic.expression.Variable;
import au.com.cybersearch2.classy_logic.expression.CallOperand;
import au.com.cybersearch2.classy_logic.expression.ParameterOperand;
import au.com.cybersearch2.classy_logic.expression.FormatterOperand;
import au.com.cybersearch2.classy_logic.expression.CurrencyOperand;
import au.com.cybersearch2.classy_logic.expression.AxiomParameterOperand;
import au.com.cybersearch2.classy_logic.expression.FactOperand;
import au.com.cybersearch2.classy_logic.expression.ChoiceOperand;
import au.com.cybersearch2.classy_logic.list.ArrayItemList;
import au.com.cybersearch2.classy_logic.list.AxiomTermList;
import au.com.cybersearch2.classy_logic.list.AxiomList;
import au.com.cybersearch2.classy_logic.list.ListLength;
import au.com.cybersearch2.classy_logic.list.ItemListVariable;
import au.com.cybersearch2.classy_logic.list.AxiomListVariable;
import au.com.cybersearch2.classy_logic.terms.StringTerm;
import au.com.cybersearch2.classy_logic.terms.IntegerTerm;
import au.com.cybersearch2.classy_logic.terms.DoubleTerm;
import au.com.cybersearch2.classy_logic.terms.BooleanTerm;
import au.com.cybersearch2.classy_logic.terms.Parameter;
import au.com.cybersearch2.classy_logic.terms.NumberTerm;
import au.com.cybersearch2.classy_logic.interfaces.Term;
import au.com.cybersearch2.classy_logic.interfaces.Operand;
import au.com.cybersearch2.classy_logic.interfaces.ItemList;
import au.com.cybersearch2.classy_logic.interfaces.AxiomProvider;
import au.com.cybersearch2.classy_logic.helper.Null;
import au.com.cybersearch2.classy_logic.helper.Unknown;
import au.com.cybersearch2.classy_logic.helper.QualifiedName;
import au.com.cybersearch2.classy_logic.helper.OperandParam;



/** 
 * QueryParser
 * JavaCC generated Expression Pattern Language Compiler 
 * @author Andrew Bowley
 * 30 Sep 2010
 */
public class QueryParser implements QueryParserConstants 
{

  /** 
   * Main entry point reads from System.in. Generates console output only. Use for validation. 
   * @throws ParseException
   */
  public static void main(String args[]) throws ParseException
  {
    QueryParser parser = new QueryParser(System.in);
    QueryProgram queryProgram = new QueryProgram();
    parser.input(queryProgram);
  }


  /** 
   * Returns compiled result of eXPL script from supplied input stream.
   * @param inputStream  InputStream
   * @return QueryProgram object
   * @throws ParseException
   */
  public QueryProgram parse(InputStream inputStream) throws ParseException
  {
    ReInit(inputStream);
    QueryProgram queryProgram = new QueryProgram();
    input(queryProgram);
    return queryProgram;
   }

  /**
   * Include eXPL script from named resource
   * @param resourceName Name of file or other resource to include
   * @param queryProgram QueryProgram object accumulating the compiled result
   * @throws ParseException
   */
  public void includeResource(String resourceName, QueryProgram queryProgram) throws ParseException
  {
     if (resourceName.length() < 3)
        throw new ParseException("Include resourceName \u005c"\u005c" is invalid");
     ParserResources parserResources = new ParserResources(queryProgram);
     try
     {
         parserResources.includeResource(resourceName.substring(1, resourceName.length() - 1));
     }
     catch (IOException e)
     {
         throw new ParseException(e.getMessage());
     }
  }

  /**
   * Returns content of string literal token stipped of quote delimiters
   * @param stringLiteral Token object
   * @return String
   */
  protected String getText(Token stringLiteral)
  {
      return stringLiteral.image.substring(1, stringLiteral.image.length() - 1);
  }

/** Root production. */
  final public void input(QueryProgram queryProgram) throws ParseException
  {
    label_1:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TEMPLATE:
      case AXIOM:
      case INCLUDE:
      case CALC:
      case LIST:
      case TERM:
      case CURRENCY:
      case LOCAL:
      case CHOICE:
      case IDENTIFIER:
        Statement(queryProgram, queryProgram.getGlobalScope());
        break;
      case QUERY:
        QueryChain(queryProgram.getGlobalScope());
        break;
      case SCOPE:
        ScopeDeclaration(queryProgram);
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TEMPLATE:
      case AXIOM:
      case INCLUDE:
      case SCOPE:
      case QUERY:
      case CALC:
      case LIST:
      case TERM:
      case CURRENCY:
      case LOCAL:
      case CHOICE:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
    }
    jj_consume_token(0);
  }

  final public void ScopeDeclaration(QueryProgram queryProgram) throws ParseException
  {
  Scope scope;
    jj_consume_token(SCOPE);
    scope = Scope(queryProgram);
    jj_consume_token(LBRACE);
    label_2:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TEMPLATE:
      case AXIOM:
      case INCLUDE:
      case QUERY:
      case CALC:
      case LIST:
      case TERM:
      case CURRENCY:
      case LOCAL:
      case CHOICE:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TEMPLATE:
      case AXIOM:
      case INCLUDE:
      case CALC:
      case LIST:
      case TERM:
      case CURRENCY:
      case LOCAL:
      case CHOICE:
      case IDENTIFIER:
        Statement(queryProgram, scope);
        break;
      case QUERY:
        QueryChain(scope);
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(RBRACE);

  }

  final public Scope Scope(QueryProgram queryProgram) throws ParseException
  {
  Token scopeToken;
  Map<String, Object> properties = new HashMap<String, Object>();
    scopeToken = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      jj_consume_token(LPAREN);
      InitialiserList(properties);
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
      {if (true) return queryProgram.scopeInstance(scopeToken.image , properties);}
    throw new Error("Missing return statement in function");
  }

  final public void QueryChain(Scope scope) throws ParseException
  {
    QuerySpec querySpec;
    jj_consume_token(QUERY);
    querySpec = Query();
    querySpec = QueryDeclaration(querySpec, scope);
    label_3:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case 79:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_3;
      }
      jj_consume_token(79);
      QueryDeclaration(querySpec.chain(), scope);
    }
    jj_consume_token(SEMICOLON);
      scope.addQuerySpec(querySpec);
  }

  final public QuerySpec QueryDeclaration(QuerySpec querySpec, Scope scope) throws ParseException
  {
  KeyName firstKeyname;
  int keynameCount = 1;
  Map<String, Object> properties = new HashMap<String, Object>();
    jj_consume_token(LPAREN);
    firstKeyname = KeyName(querySpec);
    label_4:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_4;
      }
      jj_consume_token(COMMA);
      KeyName(querySpec);
            ++keynameCount;
    }
    jj_consume_token(RPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      jj_consume_token(LPAREN);
      InitialiserList(properties);
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
        {if (true) return scope.buildQuerySpec(querySpec, firstKeyname, keynameCount, properties);}
    throw new Error("Missing return statement in function");
  }

  final public QuerySpec Query() throws ParseException
  {
    Token queryToken;
    queryToken = jj_consume_token(IDENTIFIER);
    {if (true) return new QuerySpec(queryToken.image);}
    throw new Error("Missing return statement in function");
  }

  final public void Statement(QueryProgram queryProgram, Scope scope) throws ParseException
  {
  Operand var;
  ParserAssembler parserAssembler = scope.getParserAssembler();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
    case IDENTIFIER:
      var = VariableDeclaration(parserAssembler);
      jj_consume_token(SEMICOLON);
      parserAssembler.getOperandMap().addOperand(var);
      break;
    case TEMPLATE:
      TemplateDeclaration(parserAssembler);
      jj_consume_token(SEMICOLON);
      break;
    case CALC:
      CalculatorTemplate(parserAssembler);
      jj_consume_token(SEMICOLON);
      break;
    case AXIOM:
      AxiomDeclaration(parserAssembler);
      jj_consume_token(SEMICOLON);
      break;
    case CHOICE:
      ChoiceDeclaration(parserAssembler);
      jj_consume_token(SEMICOLON);
      break;
    case LIST:
    case LOCAL:
      ListDeclaration(parserAssembler);
      jj_consume_token(SEMICOLON);
      break;
    case INCLUDE:
      Include(queryProgram);
      jj_consume_token(SEMICOLON);
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Include(QueryProgram queryProgram) throws ParseException
  {
  Token includeToken = null;
    jj_consume_token(INCLUDE);
    includeToken = jj_consume_token(STRING_LITERAL);
    includeResource(includeToken.image, queryProgram);
  }

  final public void ListDeclaration(ParserAssembler parserAssembler) throws ParseException
  {
    Token keywordToken;
    Token nameToken;
    VariableType varType = null;
    QualifiedName qualifiedAxiomName = null;
    AxiomProvider axiomProvider = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LIST:
      keywordToken = jj_consume_token(LIST);
      break;
    case LOCAL:
      keywordToken = jj_consume_token(LOCAL);
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LT:
      jj_consume_token(LT);
      varType = Type(parserAssembler.getOperandMap());
      jj_consume_token(GT);
      break;
    default:
      jj_la1[10] = jj_gen;
      ;
    }
    nameToken = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      jj_consume_token(LPAREN);
      qualifiedAxiomName = Axiom(parserAssembler);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COLON:
        jj_consume_token(COLON);
        axiomProvider = ResourceDeclaration(qualifiedAxiomName, parserAssembler);
        break;
      default:
        jj_la1[11] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
    String listName = nameToken.image;
    if ((varType == null) && (qualifiedAxiomName == null))
        {if (true) throw new ParseException("Invalid declaration for list \u005c"" + listName + "\u005c". Missing type or axiom name.");}
    if ((varType != null) && (keywordToken.kind == QueryParserConstants.LOCAL))
        {if (true) throw new ParseException("Invalid declaration for local \u005c"" + listName + "\u005c". Type in declaration not allowed.");}
    if (varType == null)
        varType = keywordToken.kind == QueryParserConstants.LIST ? new VariableType(OperandType.AXIOM) : new VariableType(OperandType.LOCAL);
    if (qualifiedAxiomName != null)
        varType.setProperty(VariableType.AXIOM_KEY, qualifiedAxiomName.getName());
    ItemList<?> itemList = varType.getItemListInstance(parserAssembler, listName);
    parserAssembler.getOperandMap().addItemList(itemList.getQualifiedName(), itemList);
    if (axiomProvider != null)
        parserAssembler.registerAxiomListener(qualifiedAxiomName, axiomProvider.getAxiomListener());
  }

  final public VariableType Type(OperandMap operandMap) throws ParseException
  {
    Token qualifierLit = null;
    String qualifierId = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
      jj_consume_token(INTEGER);
      {if (true) return new VariableType(OperandType.INTEGER);}
      break;
    case BOOLEAN:
      jj_consume_token(BOOLEAN);
      {if (true) return new VariableType(OperandType.BOOLEAN);}
      break;
    case DOUBLE:
      jj_consume_token(DOUBLE);
      {if (true) return new VariableType(OperandType.DOUBLE);}
      break;
    case STRING:
      jj_consume_token(STRING);
      {if (true) return new VariableType(OperandType.STRING);}
      break;
    case DECIMAL:
      jj_consume_token(DECIMAL);
      {if (true) return new VariableType(OperandType.DECIMAL);}
      break;
    case TERM:
      jj_consume_token(TERM);
      {if (true) return new VariableType(OperandType.TERM);}
      break;
    case CURRENCY:
      jj_consume_token(CURRENCY);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LPAREN:
        jj_consume_token(LPAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case STRING_LITERAL:
          qualifierLit = jj_consume_token(STRING_LITERAL);
          break;
        case IDENTIFIER:
          qualifierId = Name();
          break;
        default:
          jj_la1[13] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[14] = jj_gen;
        ;
      }
      VariableType varType = new VariableType(OperandType.CURRENCY);
      if (qualifierLit != null)
         varType.setProperty(VariableType.QUALIFIER_STRING, getText(qualifierLit));
      else if (qualifierId != null)
         varType.setProperty(VariableType.QUALIFIER_OPERAND, operandMap.addOperand(qualifierId, null));
      {if (true) return varType;}
      break;
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void TemplateDeclaration(ParserAssembler parserAssembler) throws ParseException
  {
    Template template;
    QualifiedName contextName = parserAssembler.getOperandMap().getQualifiedContextname();
    jj_consume_token(TEMPLATE);
    template = Template(parserAssembler, false);
    jj_consume_token(LPAREN);
    TemplateExpression(template, parserAssembler);
    label_5:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_5;
      }
      jj_consume_token(COMMA);
      TemplateExpression(template, parserAssembler);
    }
    jj_consume_token(RPAREN);
      parserAssembler.getOperandMap().setQualifiedContextname(contextName);
  }

  final public Template Template(ParserAssembler parserAssembler, boolean isCalculator) throws ParseException
  {
    Token templateToken;
    templateToken = jj_consume_token(IDENTIFIER);
      QualifiedName qualifiedTemplateName = new QualifiedName(parserAssembler.getScope().getAlias(), templateToken.image, QualifiedName.EMPTY);
      parserAssembler.getOperandMap().setQualifiedContextname(qualifiedTemplateName);
      {if (true) return parserAssembler.createTemplate(qualifiedTemplateName, isCalculator);}
    throw new Error("Missing return statement in function");
  }

  final public void CalculatorTemplate(ParserAssembler parserAssembler) throws ParseException
  {
    Template template;
    Map<String, Object> properties = new HashMap<String, Object>();
    int loopNumber = 0;
    QualifiedName contextName = parserAssembler.getOperandMap().getQualifiedContextname();
    jj_consume_token(CALC);
    template = Template(parserAssembler, true);
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case AXIOM:
    case FACT:
    case LENGTH:
    case TERM:
    case CURRENCY:
    case FORMAT:
    case CHOICE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case LBRACE:
    case BANG:
    case COLON:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 80:
    case 82:
      CalculatorExpression(loopNumber, template, template.getName(), parserAssembler);
      break;
    case TEMPLATE:
    case 81:
      CalculatorQuery(template, parserAssembler);
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_6:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[18] = jj_gen;
        break label_6;
      }
      jj_consume_token(COMMA);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case AXIOM:
      case FACT:
      case LENGTH:
      case TERM:
      case CURRENCY:
      case FORMAT:
      case CHOICE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case NUMBER_LITERAL:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case UNKNOWN:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case BANG:
      case COLON:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
      case 80:
      case 82:
        CalculatorExpression(loopNumber, template, template.getName(), parserAssembler);
        break;
      case TEMPLATE:
      case 81:
        CalculatorQuery(template, parserAssembler);
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(RPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      jj_consume_token(LPAREN);
      InitialiserList(properties);
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[20] = jj_gen;
      ;
    }
      if (properties.size() > 0)
          template.addProperties(properties);
      parserAssembler.getOperandMap().setQualifiedContextname(contextName);
  }

  final public void InitialiserList(Map<String, Object> properties) throws ParseException
  {
    InitialiserDeclaration(properties);
    label_7:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[21] = jj_gen;
        break label_7;
      }
      jj_consume_token(COMMA);
      InitialiserDeclaration(properties);
    }
  }

  final public void InitialiserDeclaration(Map<String, Object> properties) throws ParseException
  {
    String name;
    Parameter param;
    name = Name();
    jj_consume_token(ASSIGN);
    param = LiteralTerm();
     properties.put(name, param.getValue());
  }

  final public Operand VariableDeclaration(ParserAssembler parserAssembler) throws ParseException
  {
    Token nameToken;
    VariableType varType = null;
    Operand index = null;
    Operand expression = null;
    OperandMap operandMap = parserAssembler.getOperandMap();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
      varType = Type(operandMap);
      break;
    default:
      jj_la1[22] = jj_gen;
      ;
    }
    nameToken = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LBRACKET:
      index = IndexExpression(parserAssembler);
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      expression = Expression(parserAssembler);
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
     String name = nameToken.image;
     if (index !=null)
         {if (true) return parserAssembler.setListVariable(name, index, expression);}
     if (varType == null)
         varType = new VariableType(OperandType.UNKNOWN);
     boolean isLiteral = (expression != null) &&
                          !expression.isEmpty() && !(expression instanceof Evaluator);
     if (expression != null)
         varType.setProperty(isLiteral ? VariableType.LITERAL : VariableType.EXPRESSION, expression);
     Operand operand = varType.getInstance(parserAssembler, name);
     {if (true) return operand;}
    throw new Error("Missing return statement in function");
  }

  final public void TemplateExpression(Template template, ParserAssembler parserAssembler) throws ParseException
  {
    String name;
    VariableType varType = null;
    VariableType listVarType = null;
    Operand index = null;
    Operand var = null;
    Token scToken = null;
    Token assignToken = null;
    Token equalsToken = null;
    Token regexLit = null;
    Token regexId = null;
    Operand expression = null;
    Group group = null;
    OperandMap operandMap = parserAssembler.getOperandMap();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
      varType = Type(operandMap);
      break;
    default:
      jj_la1[25] = jj_gen;
      ;
    }
    name = Name();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LBRACKET:
      index = IndexExpression(parserAssembler);
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case REGEX:
    case ASSIGN:
    case COLON:
    case PLUSASSIGN:
    case MINUSASSIGN:
    case STARASSIGN:
    case SLASHASSIGN:
    case ANDASSIGN:
    case ORASSIGN:
    case XORASSIGN:
    case REMASSIGN:
    case 80:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case ASSIGN:
      case COLON:
      case PLUSASSIGN:
      case MINUSASSIGN:
      case STARASSIGN:
      case SLASHASSIGN:
      case ANDASSIGN:
      case ORASSIGN:
      case XORASSIGN:
      case REMASSIGN:
      case 80:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case COLON:
          scToken = jj_consume_token(COLON);
          break;
        case 80:
          scToken = jj_consume_token(80);
          break;
        case ASSIGN:
          equalsToken = jj_consume_token(ASSIGN);
          break;
        case PLUSASSIGN:
        case MINUSASSIGN:
        case STARASSIGN:
        case SLASHASSIGN:
        case ANDASSIGN:
        case ORASSIGN:
        case XORASSIGN:
        case REMASSIGN:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
          {
          case PLUSASSIGN:
            assignToken = jj_consume_token(PLUSASSIGN);
            break;
          case MINUSASSIGN:
            assignToken = jj_consume_token(MINUSASSIGN);
            break;
          case STARASSIGN:
            assignToken = jj_consume_token(STARASSIGN);
            break;
          case SLASHASSIGN:
            assignToken = jj_consume_token(SLASHASSIGN);
            break;
          case ANDASSIGN:
            assignToken = jj_consume_token(ANDASSIGN);
            break;
          case ORASSIGN:
            assignToken = jj_consume_token(ORASSIGN);
            break;
          case XORASSIGN:
            assignToken = jj_consume_token(XORASSIGN);
            break;
          case REMASSIGN:
            assignToken = jj_consume_token(REMASSIGN);
            break;
          default:
            jj_la1[27] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[28] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        expression = Expression(parserAssembler);
        break;
      case REGEX:
        jj_consume_token(REGEX);
        jj_consume_token(LPAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case STRING_LITERAL:
          regexLit = jj_consume_token(STRING_LITERAL);
          break;
        case IDENTIFIER:
          regexId = jj_consume_token(IDENTIFIER);
          break;
        default:
          jj_la1[29] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case LBRACE:
          group = GroupDeclaration(template, name, parserAssembler);
          break;
        default:
          jj_la1[30] = jj_gen;
          ;
        }
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[31] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
     if (varType == null)
         varType = new VariableType(OperandType.UNKNOWN);
     Operand assignExpression = (assignToken != null) ? expression : null;
     Operand regexOp = null;
     if (regexLit != null)
         regexOp = new StringOperand(QualifiedName.ANONYMOUS, getText(regexLit));
     else if (regexId != null)
         regexOp = operandMap.addOperand(regexId.image, null);
     if (assignToken != null)
         expression = null;
     boolean isLiteral = (expression != null) &&
                          !expression.isEmpty() && !(expression instanceof Evaluator) &&
                          (equalsToken != null);
     if (expression != null)
         varType.setProperty(isLiteral ? VariableType.LITERAL : VariableType.EXPRESSION, expression);
     if (index !=null)
       var = parserAssembler.setListVariable(name, index, null);
     else if (regexOp != null)
       var = new RegExOperand(parserAssembler.getContextName(name), regexOp, 0, group);
     else if (scToken != null)
       var = new Evaluator(parserAssembler.getContextName(name), expression, (scToken.image == "?" ? "&&" : "||"));
     else if (!operandMap.hasOperand(name))
       var = varType.getInstance(parserAssembler, name);
     else if (!template.isInnerTemplate())
       var = operandMap.addOperand(name, expression);
     else
       var = new Variable(parserAssembler.getContextName(name), expression);
     if ((index ==null) && (!operandMap.hasOperand(name)) && !template.isInnerTemplate())
        operandMap.addOperand(var);
     if (assignToken != null)
        var = new Evaluator(parserAssembler.getContextName(name), var, assignToken.image, assignExpression);
     if ((index !=null) && (equalsToken != null))
        var = new Evaluator(parserAssembler.getContextName(expression.getName()), var, "=", expression);
     template.addTerm(var);
  }

  final public void CalculatorExpression(int loop_number, Template template, String templateName, ParserAssembler parserAssembler) throws ParseException
  {
  Token scToken = null;
  Operand expression = null;
  Operand innerLoop = null;
  QualifiedName qualifiedAxiomName;
  QualifiedName qualifiedTemplateName;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case AXIOM:
      jj_consume_token(AXIOM);
      qualifiedAxiomName = Axiom(parserAssembler);
      expression = AxiomVariable(qualifiedAxiomName, parserAssembler);
    parserAssembler.getOperandMap().addOperand(expression);
    template.addTerm(expression);
      break;
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case TERM:
    case CURRENCY:
    case IDENTIFIER:
      TemplateExpression(template, parserAssembler);
      break;
    case FACT:
    case LENGTH:
    case FORMAT:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case LPAREN:
    case BANG:
    case COLON:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 80:
    case 82:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COLON:
      case 80:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case COLON:
          scToken = jj_consume_token(COLON);
          break;
        case 80:
          scToken = jj_consume_token(80);
          break;
        default:
          jj_la1[33] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[34] = jj_gen;
        ;
      }
      expression = Expression(parserAssembler);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LBRACE:
        innerLoop = InnerCalculator(loop_number + 1, templateName, parserAssembler, scToken != null);
        break;
      default:
        jj_la1[35] = jj_gen;
        ;
      }
    if (scToken != null)
      expression = new Evaluator(expression, (scToken.image == "?" ? "&&" : "||"), innerLoop);
    template.addTerm(expression);
      break;
    case LBRACE:
      innerLoop = InnerCalculator(loop_number + 1, templateName, parserAssembler, false);
    template.addTerm(innerLoop);
      break;
    case CHOICE:
      qualifiedTemplateName = ChoiceDeclaration(parserAssembler);
    Template choiceTemplate = parserAssembler.getTemplate(qualifiedTemplateName);
    QualifiedName contextName = parserAssembler.getOperandMap().getQualifiedContextname();
    QualifiedName qname = QualifiedName.parseName(choiceTemplate.getName(), contextName);
        Choice choice = new Choice(choiceTemplate.getName(), parserAssembler.getScope());
    Operand choiceOperand = new ChoiceOperand(qname, choiceTemplate, choice);
    template.addTerm(choiceOperand);
      break;
    default:
      jj_la1[36] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public Operand InnerCalculator(int loop_number, String templateName, ParserAssembler parserAssembler, boolean runOnce) throws ParseException
  {
  Operand calcExpression;
  String loopName = templateName + loop_number;
  QualifiedName qualifiedTemplateName = new QualifiedName(parserAssembler.getScope().getAlias(), templateName, QualifiedName.EMPTY);
  Template template = parserAssembler.chainTemplate(qualifiedTemplateName, loopName);
    jj_consume_token(LBRACE);
    CalculatorExpression(loop_number, template, templateName, parserAssembler);
    label_8:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[37] = jj_gen;
        break label_8;
      }
      jj_consume_token(COMMA);
      CalculatorExpression(loop_number, template, templateName, parserAssembler);
    }
    jj_consume_token(RBRACE);
    {if (true) return new LoopEvaluator(template, runOnce);}
    throw new Error("Missing return statement in function");
  }

  final public void CalculatorQuery(Template template, ParserAssembler parserAssembler) throws ParseException
  {
  String queryName;
  List<OperandParam> operandParamList = null;
  Template innerTemplate = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case TEMPLATE:
      innerTemplate = InnerTemplateDeclaration(template.getQualifiedName(), parserAssembler);
      break;
    default:
      jj_la1[38] = jj_gen;
      ;
    }
    jj_consume_token(81);
    queryName = Name();
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case FACT:
    case LENGTH:
    case TERM:
    case CURRENCY:
    case FORMAT:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 82:
      operandParamList = ArgumentList(parserAssembler, false);
      break;
    default:
      jj_la1[39] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
    QualifiedName qname = QualifiedName.parseName(queryName);
    Operand queryOperand = parserAssembler.getQueryOperand(qname, operandParamList, innerTemplate);
    template.addTerm(queryOperand);
    if (innerTemplate != null)
        parserAssembler.addInnerTemplate(innerTemplate);
  }

  final public Operand CalculatorFunction(ParserAssembler parserAssembler) throws ParseException
  {
    String fnName;
    List<OperandParam> operandParamList = null;
    fnName = Name();
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case FACT:
    case LENGTH:
    case TERM:
    case CURRENCY:
    case FORMAT:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 82:
      operandParamList = ArgumentList(parserAssembler, true);
      break;
    default:
      jj_la1[40] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
    {if (true) return parserAssembler.getCallOperand(parserAssembler.getContextName(fnName), operandParamList);}
    throw new Error("Missing return statement in function");
  }

  final public Template InnerTemplateDeclaration(QualifiedName ownerQualifiedName, ParserAssembler parserAssembler) throws ParseException
  {
    Template template;
    jj_consume_token(TEMPLATE);
    template = InnerTemplate(ownerQualifiedName, parserAssembler);
    jj_consume_token(LPAREN);
    TemplateExpression(template, parserAssembler);
    label_9:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[41] = jj_gen;
        break label_9;
      }
      jj_consume_token(COMMA);
      TemplateExpression(template, parserAssembler);
    }
    jj_consume_token(RPAREN);
        {if (true) return template;}
    throw new Error("Missing return statement in function");
  }

  final public Template InnerTemplate(QualifiedName ownerQualifiedName, ParserAssembler parserAssembler) throws ParseException
  {
    Token templateToken;
    templateToken = jj_consume_token(IDENTIFIER);
    QualifiedName qualifiedTemplateName = new QualifiedName(templateToken.image, ownerQualifiedName);
    Template innerTemplate = parserAssembler.createTemplate(qualifiedTemplateName, false);
    innerTemplate.setInnerTemplate(true);
    innerTemplate.setKey(templateToken.image);
    {if (true) return innerTemplate;}
    throw new Error("Missing return statement in function");
  }

  final public Operand AxiomVariable(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
    Operand expression = null;
    List<OperandParam> axiomList = null;
    jj_consume_token(ASSIGN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case FACT:
    case LENGTH:
    case FORMAT:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 82:
      expression = Expression(parserAssembler);
      break;
    case LBRACE:
      axiomList = AxiomList(qualifiedAxiomName, parserAssembler);
      break;
    default:
      jj_la1[42] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     VariableType varType = new VariableType(axiomList == null ? OperandType.AXIOM : OperandType.LIST);
     if (expression != null)
         varType.setProperty(VariableType.EXPRESSION, expression);
     else
         varType.setProperty(VariableType.PARAMS, axiomList);
     Operand operand = varType.getInstance(parserAssembler, qualifiedAxiomName);
     if (expression != null)
         parserAssembler.setParameter(operand.getQualifiedName());
     {if (true) return operand;}
    throw new Error("Missing return statement in function");
  }

  final public List<OperandParam> AxiomList(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
  String axiomName = qualifiedAxiomName.getName();
  String listName = axiomName + "_list";
  List<OperandParam> operandParamList = new ArrayList<OperandParam>();
  Operand operand;
  int count = 0;
    operand = AxiomInitializer(listName + "0", axiomName, parserAssembler);
    operandParamList.add(new OperandParam(axiomName, operand));
    label_10:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[43] = jj_gen;
        break label_10;
      }
      operand = AxiomInitializer(listName + ++count, axiomName, parserAssembler);
      operandParamList.add(new OperandParam(axiomName, operand));
    }
    {if (true) return operandParamList;}
    throw new Error("Missing return statement in function");
  }

  final public Operand AxiomInitializer(String listName, String axiomName, ParserAssembler parserAssembler) throws ParseException
  {
    List<OperandParam> initializeList = null;
    jj_consume_token(LBRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER:
    case DOUBLE:
    case DECIMAL:
    case BOOLEAN:
    case STRING:
    case FACT:
    case LENGTH:
    case TERM:
    case CURRENCY:
    case FORMAT:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case 82:
      initializeList = ArgumentList(parserAssembler, true);
      break;
    default:
      jj_la1[44] = jj_gen;
      ;
    }
    jj_consume_token(RBRACE);
     VariableType varType = new VariableType(OperandType.TERM);
     varType.setProperty(VariableType.AXIOM_KEY, axiomName);
     if (initializeList != null)
        varType.setProperty(VariableType.PARAMS, initializeList);
     Operand operand = varType.getInstance(parserAssembler, listName);
     {if (true) return operand;}
    throw new Error("Missing return statement in function");
  }

  final public Group GroupDeclaration(Template template, String name, ParserAssembler parserAssembler) throws ParseException
  {
  Group group = new Group(name);
    jj_consume_token(LBRACE);
    Group(group, template, name, parserAssembler);
    label_11:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[45] = jj_gen;
        break label_11;
      }
      jj_consume_token(COMMA);
      Group(group, template, name, parserAssembler);
    }
    jj_consume_token(RBRACE);
    {if (true) return group;}
    throw new Error("Missing return statement in function");
  }

  final public void Group(Group group, Template template, String name, ParserAssembler parserAssembler) throws ParseException
  {
  Token groupToken;
    groupToken = jj_consume_token(IDENTIFIER);
    Operand var = parserAssembler.getOperandMap().addOperand(groupToken.image, null);
    template.addTerm(var);
    group.addGroup(var);
  }

  final public void AxiomDeclaration(ParserAssembler parserAssembler) throws ParseException
  {
    QualifiedName qualifiedAxiomName;
    Operand operand = null;
    jj_consume_token(AXIOM);
    qualifiedAxiomName = Axiom(parserAssembler);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
    case COLON:
      AxiomSpecification(qualifiedAxiomName, parserAssembler);
      break;
    case ASSIGN:
      operand = AxiomVariable(qualifiedAxiomName, parserAssembler);
      break;
    default:
      jj_la1[46] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        if (operand != null)
            parserAssembler.getOperandMap().addOperand(operand);
  }

  final public void AxiomSpecification(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
    parserAssembler.createAxiom(qualifiedAxiomName);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      jj_consume_token(LPAREN);
      TermName(qualifiedAxiomName, parserAssembler);
      label_12:
      while (true) 
      {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case COMMA:
          ;
          break;
        default:
          jj_la1[47] = jj_gen;
          break label_12;
        }
        jj_consume_token(COMMA);
        TermName(qualifiedAxiomName, parserAssembler);
      }
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[48] = jj_gen;
      ;
    }
    jj_consume_token(COLON);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      AxiomItem(qualifiedAxiomName, parserAssembler);
      label_13:
      while (true) 
      {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
        {
        case COMMA:
          ;
          break;
        default:
          jj_la1[49] = jj_gen;
          break label_13;
        }
        jj_consume_token(COMMA);
        AxiomItem(qualifiedAxiomName, parserAssembler);
      }
      break;
    case RESOURCE:
      ResourceDeclaration(qualifiedAxiomName, parserAssembler);
      break;
    case PARAMETER:
      ParameterDeclaration(qualifiedAxiomName, parserAssembler);
      break;
    default:
      jj_la1[50] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public QualifiedName ChoiceDeclaration(ParserAssembler parserAssembler) throws ParseException
  {
    QualifiedName qualifiedAxiomName;
    int selection = 0;
    OperandMap operandMap = parserAssembler.getOperandMap();
    jj_consume_token(CHOICE);
    qualifiedAxiomName = Choice(parserAssembler);
    jj_consume_token(LPAREN);
    TermName(qualifiedAxiomName, parserAssembler);
    label_14:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[51] = jj_gen;
        break label_14;
      }
      jj_consume_token(COMMA);
      TermName(qualifiedAxiomName, parserAssembler);
    }
    jj_consume_token(RPAREN);
    jj_consume_token(COLON);
    ChoiceItem(selection, qualifiedAxiomName, parserAssembler);
    label_15:
    while (true) 
    {
      if (jj_2_1(2)) 
      {
        ;
      } else 
      {
        break label_15;
      }
      jj_consume_token(COMMA);
      ChoiceItem(++selection, qualifiedAxiomName, parserAssembler);
    }
      QualifiedName contextName = parserAssembler.getOperandMap().getQualifiedContextname();
      QualifiedName qualifiedTemplateName = new QualifiedName(contextName.getScope(), qualifiedAxiomName.getName(), QualifiedName.EMPTY);
      if (contextName.getTemplate().isEmpty())
          {if (true) return qualifiedTemplateName;}
      parserAssembler.getOperandMap().setQualifiedContextname(contextName);
      List<String> termNameList = parserAssembler.getAxiomTermNameList(qualifiedAxiomName);
      for (String termName: termNameList)
          parserAssembler.getOperandMap().addOperand(termName, null);
      operandMap.setQualifiedContextname(contextName);
      {if (true) return qualifiedTemplateName;}
    throw new Error("Missing return statement in function");
  }

  final public QualifiedName Axiom(ParserAssembler parserAssembler) throws ParseException
  {
    Token axiomToken;
    axiomToken = jj_consume_token(IDENTIFIER);
    {if (true) return parserAssembler.getContextName(axiomToken.image);}
    throw new Error("Missing return statement in function");
  }

  final public QualifiedName Choice(ParserAssembler parserAssembler) throws ParseException
  {
    Token choiceToken;
    choiceToken = jj_consume_token(IDENTIFIER);
    QualifiedName qualifiedChoiceName = parserAssembler.getContextName(choiceToken.image);
    parserAssembler.createAxiom(qualifiedChoiceName);
    QualifiedName qualifiedTemplateName = new QualifiedName(parserAssembler.getScope().getAlias(), qualifiedChoiceName.getName(), QualifiedName.EMPTY);
    Template template = parserAssembler.createTemplate(qualifiedTemplateName, true);
    template.setChoice(true);
    {if (true) return qualifiedChoiceName;}
    throw new Error("Missing return statement in function");
  }

  final public void TermName(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
    Token nameToken;
    nameToken = jj_consume_token(IDENTIFIER);
      parserAssembler.addAxiomTermName(qualifiedAxiomName, nameToken.image);
  }

  final public void AxiomItem(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
    jj_consume_token(LPAREN);
    Fact(qualifiedAxiomName, parserAssembler);
    label_16:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[52] = jj_gen;
        break label_16;
      }
      jj_consume_token(COMMA);
      Fact(qualifiedAxiomName, parserAssembler);
    }
    jj_consume_token(RPAREN);
      parserAssembler.saveAxiom(qualifiedAxiomName);
  }

  final public void ChoiceItem(int selection, QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
    Operand operand;
    String name = parserAssembler.getAxiomTermName(qualifiedAxiomName, 0);
    parserAssembler.addAxiom(qualifiedAxiomName, new Parameter(Term.ANONYMOUS, new Null()));
    jj_consume_token(LPAREN);
    operand = ChoiceExpression(name, parserAssembler);
    label_17:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[53] = jj_gen;
        break label_17;
      }
      jj_consume_token(COMMA);
      Fact(qualifiedAxiomName, parserAssembler);
    }
    jj_consume_token(RPAREN);
       parserAssembler.saveAxiom(qualifiedAxiomName);
       QualifiedName qualifiedTemplateName = new QualifiedName(parserAssembler.getScope().getAlias(), qualifiedAxiomName.getName(), QualifiedName.EMPTY);
       parserAssembler.addTemplate(qualifiedTemplateName, operand);
  }

  final public Operand ChoiceExpression(String name, ParserAssembler parserAssembler) throws ParseException
  {
    Operand operand;
    QualifiedName qname = parserAssembler.getContextName(name);
    operand = Expression(parserAssembler);
      if (operand instanceof Evaluator)
          {if (true) return new Evaluator(qname, operand, "&&" );}
      if (operand instanceof StringOperand)
          {if (true) return new RegExOperand(qname, operand, 0, null);}
      {if (true) return new MatchOperand(qname, operand);}
    throw new Error("Missing return statement in function");
  }

  final public AxiomProvider ResourceDeclaration(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
  Token nameToken;
  Map<String, Object> properties = new HashMap<String, Object>();
    jj_consume_token(RESOURCE);
    nameToken = jj_consume_token(STRING_LITERAL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LPAREN:
      jj_consume_token(LPAREN);
      InitialiserList(properties);
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[54] = jj_gen;
      ;
    }
    {if (true) return parserAssembler.setResourceProperties(getText(nameToken), qualifiedAxiomName, properties);}
    throw new Error("Missing return statement in function");
  }

  final public void ParameterDeclaration(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
    jj_consume_token(PARAMETER);
    parserAssembler.setParameter(qualifiedAxiomName);
  }

  final public void Fact(QualifiedName qualifiedAxiomName, ParserAssembler parserAssembler) throws ParseException
  {
  Parameter param = null;
  Token lit = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
      param = LiteralTerm();
    parserAssembler.addAxiom(qualifiedAxiomName, param);
      break;
    case NUMBER_LITERAL:
      lit = jj_consume_token(NUMBER_LITERAL);
    parserAssembler.addAxiom(qualifiedAxiomName, new NumberTerm(getText(lit), parserAssembler.getScopeLocale()));
      break;
    case NAN:
      jj_consume_token(NAN);
    parserAssembler.addAxiom(qualifiedAxiomName, new DoubleTerm("NaN"));
      break;
    default:
      jj_la1[55] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public String Name() throws ParseException
  {
  String name;
  Token partToken;
    partToken = jj_consume_token(IDENTIFIER);
    name = partToken.image;
    label_18:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case DOT:
        ;
        break;
      default:
        jj_la1[56] = jj_gen;
        break label_18;
      }
      jj_consume_token(DOT);
      partToken = jj_consume_token(IDENTIFIER);
      name += ("." + partToken.image);
    }
    {if (true) return name;}
    throw new Error("Missing return statement in function");
  }

  final public KeyName KeyName(QuerySpec querySpec) throws ParseException
  {
  String axiomKey = null;
  String templateName;
    if (jj_2_2(2)) 
    {
      axiomKey = Name();
      jj_consume_token(COLON);
    } else 
    {
      ;
    }
    templateName = Name();
    KeyName keyname = new KeyName(axiomKey == null ? "" : axiomKey, templateName);
    querySpec.addKeyName(keyname);
    {if (true) return keyname;}
    throw new Error("Missing return statement in function");
  }

  final public Operand Expression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand param;
  Token assignToken = null;
  Operand assignOperand = null;
    param = ConditionalOrExpression(parserAssembler);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case ASSIGN:
    case PLUSASSIGN:
    case MINUSASSIGN:
    case STARASSIGN:
    case SLASHASSIGN:
    case ANDASSIGN:
    case ORASSIGN:
    case XORASSIGN:
    case REMASSIGN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case ASSIGN:
        assignToken = jj_consume_token(ASSIGN);
        break;
      case PLUSASSIGN:
        assignToken = jj_consume_token(PLUSASSIGN);
        break;
      case MINUSASSIGN:
        assignToken = jj_consume_token(MINUSASSIGN);
        break;
      case STARASSIGN:
        assignToken = jj_consume_token(STARASSIGN);
        break;
      case SLASHASSIGN:
        assignToken = jj_consume_token(SLASHASSIGN);
        break;
      case ANDASSIGN:
        assignToken = jj_consume_token(ANDASSIGN);
        break;
      case ORASSIGN:
        assignToken = jj_consume_token(ORASSIGN);
        break;
      case XORASSIGN:
        assignToken = jj_consume_token(XORASSIGN);
        break;
      case REMASSIGN:
        assignToken = jj_consume_token(REMASSIGN);
        break;
      default:
        jj_la1[57] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      assignOperand = Expression(parserAssembler);
      break;
    default:
      jj_la1[58] = jj_gen;
      ;
    }
    if (assignOperand == null)
      {if (true) return param;}
    {if (true) return new Evaluator(param, assignToken.image, assignOperand);}
    throw new Error("Missing return statement in function");
  }

  final public Operand ConditionalOrExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = ConditionalAndExpression(parserAssembler);
    label_19:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case SC_OR:
        ;
        break;
      default:
        jj_la1[59] = jj_gen;
        break label_19;
      }
      op = jj_consume_token(SC_OR);
      params[1] = ConditionalAndExpression(parserAssembler);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand ConditionalAndExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = InclusiveOrExpression(parserAssembler);
    label_20:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case SC_AND:
        ;
        break;
      default:
        jj_la1[60] = jj_gen;
        break label_20;
      }
      op = jj_consume_token(SC_AND);
      params[1] = InclusiveOrExpression(parserAssembler);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand InclusiveOrExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = ExclusiveOrExpression(parserAssembler);
    label_21:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case BIT_OR:
        ;
        break;
      default:
        jj_la1[61] = jj_gen;
        break label_21;
      }
      op = jj_consume_token(BIT_OR);
      params[1] = ExclusiveOrExpression(parserAssembler);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand ExclusiveOrExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = AndExpression(parserAssembler);
    label_22:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case XOR:
        ;
        break;
      default:
        jj_la1[62] = jj_gen;
        break label_22;
      }
      op = jj_consume_token(XOR);
      params[1] = AndExpression(parserAssembler);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand AndExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = EqualityExpression(parserAssembler);
    label_23:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case BIT_AND:
        ;
        break;
      default:
        jj_la1[63] = jj_gen;
        break label_23;
      }
      op = jj_consume_token(BIT_AND);
      params[1] = EqualityExpression(parserAssembler);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand EqualityExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = RelationalExpression(parserAssembler);
    label_24:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case EQ:
      case NE:
        ;
        break;
      default:
        jj_la1[64] = jj_gen;
        break label_24;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case EQ:
        op = jj_consume_token(EQ);
        break;
      case NE:
        op = jj_consume_token(NE);
        break;
      default:
        jj_la1[65] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      params[1] = RelationalExpression(parserAssembler);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand RelationalExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = AdditiveExpression(parserAssembler);
    label_25:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case GT:
      case LT:
      case LE:
      case GE:
        ;
        break;
      default:
        jj_la1[66] = jj_gen;
        break label_25;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LT:
        op = jj_consume_token(LT);
        break;
      case GT:
        op = jj_consume_token(GT);
        break;
      case LE:
        op = jj_consume_token(LE);
        break;
      case GE:
        op = jj_consume_token(GE);
        break;
      default:
        jj_la1[67] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      params[1] = AdditiveExpression(parserAssembler);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand AdditiveExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = MultiplicativeExpression(parserAssembler);
    label_26:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[68] = jj_gen;
        break label_26;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case PLUS:
        op = jj_consume_token(PLUS);
        break;
      case MINUS:
        op = jj_consume_token(MINUS);
        break;
      default:
        jj_la1[69] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      params[1] = MultiplicativeExpression(parserAssembler);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand MultiplicativeExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand[] params = new Operand[2];
  Token op;
    params[0] = UnaryExpression(parserAssembler);
    label_27:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case STAR:
      case SLASH:
      case REM:
        ;
        break;
      default:
        jj_la1[70] = jj_gen;
        break label_27;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case STAR:
        op = jj_consume_token(STAR);
        break;
      case SLASH:
        op = jj_consume_token(SLASH);
        break;
      case REM:
        op = jj_consume_token(REM);
        break;
      default:
        jj_la1[71] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      params[1] = UnaryExpression(parserAssembler);
      params[0] = new Evaluator(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public Operand UnaryExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand param;
  boolean plus = false;
  boolean minus = false;
  boolean tilde = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case PLUS:
    case MINUS:
    case 82:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case PLUS:
        jj_consume_token(PLUS);
    plus = true;
        break;
      case MINUS:
        jj_consume_token(MINUS);
    minus = true;
        break;
      case 82:
        jj_consume_token(82);
    tilde = true;
        break;
      default:
        jj_la1[72] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      param = UnaryExpression(parserAssembler);
    if (plus)
      {if (true) return new Evaluator("+", param);}
    else if (minus)
      {if (true) return new Evaluator("-", param);}
    else if (tilde)
      {if (true) return new Evaluator("~", param);}
    {if (true) return param;}
      break;
    case INCR:
      param = PreIncrementExpression(parserAssembler);
    {if (true) return param;}
      break;
    case DECR:
      param = PreDecrementExpression(parserAssembler);
    {if (true) return param;}
      break;
    case FACT:
    case LENGTH:
    case FORMAT:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
      param = UnaryExpressionNotPlusMinus(parserAssembler);
    {if (true) return param;}
      break;
    default:
      jj_la1[73] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Operand PreIncrementExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand param;
    jj_consume_token(INCR);
    param = PrimaryExpression(parserAssembler);
    {if (true) return new Evaluator("++", param);}
    throw new Error("Missing return statement in function");
  }

  final public Operand PreDecrementExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand param;
    jj_consume_token(DECR);
    param = PrimaryExpression(parserAssembler);
    {if (true) return new Evaluator("--", param);}
    throw new Error("Missing return statement in function");
  }

  final public Operand UnaryExpressionNotPlusMinus(ParserAssembler parserAssembler) throws ParseException
  {
  Operand param;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case BANG:
      jj_consume_token(BANG);
      param = UnaryExpression(parserAssembler);
    {if (true) return new Evaluator("!", param);}
      break;
    case FACT:
    case LENGTH:
    case FORMAT:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
      param = PostfixExpression(parserAssembler);
    {if (true) return param;}
      break;
    default:
      jj_la1[74] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Operand PostfixExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand param;
  boolean incr = false;
  boolean decr = false;
    param = PrimaryExpression(parserAssembler);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INCR:
    case DECR:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INCR:
        jj_consume_token(INCR);
    incr = true;
        break;
      case DECR:
        jj_consume_token(DECR);
    decr = true;
        break;
      default:
        jj_la1[75] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[76] = jj_gen;
      ;
    }
    if (incr)
       {if (true) return new Evaluator(param, "++");}
    else if (decr)
       {if (true) return new Evaluator(param, "--");}
    {if (true) return param;}
    throw new Error("Missing return statement in function");
  }

  final public Operand PrimaryExpression(ParserAssembler parserAssembler) throws ParseException
  {
  String name = null;
  QualifiedName qname;
  Token literal = null;
  Operand param1 = null;
  Operand param2 = null;
  Operand operand;
  OperandMap operandMap = parserAssembler.getOperandMap();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
      param1 = Literal();
    {if (true) return param1;}
      break;
    case NUMBER_LITERAL:
      literal = jj_consume_token(NUMBER_LITERAL);
    NumberTerm numberTerm = new NumberTerm(getText(literal), parserAssembler.getScopeLocale());
    Variable var = new Variable(QualifiedName.ANONYMOUS);
    var.assign(numberTerm.getValue());
    {if (true) return var;}
      break;
    case IDENTIFIER:
      name = Name();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case LPAREN:
      case LBRACKET:
        param1 = NamedExpression(name, parserAssembler);
        break;
      default:
        jj_la1[77] = jj_gen;
        ;
      }
    if (param1 == null)
        {if (true) return operandMap.addOperand(name, null);}
    {if (true) return param1;}
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      param1 = Expression(parserAssembler);
      jj_consume_token(RPAREN);
    {if (true) return param1;}
      break;
    case LENGTH:
      jj_consume_token(LENGTH);
      jj_consume_token(LPAREN);
      name = Name();
      jj_consume_token(RPAREN);
    qname = parserAssembler.getContextName(name);
    operand = parserAssembler.findOperandByName(name);
    if (operand != null)
        {if (true) return new ListLength(qname, operand);}
    else
        {if (true) return new ListLength(qname, parserAssembler.getItemList(name));}
      break;
    case FORMAT:
      jj_consume_token(FORMAT);
      jj_consume_token(LPAREN);
      name = Name();
      jj_consume_token(RPAREN);
    qname = parserAssembler.getContextName(name + "_format");
    operand = parserAssembler.findOperandByName(name);
    if (operand == null)
        {if (true) throw new ParseException("Variable \u005c"" + name + "\u005c" not found");}
    Scope scope = parserAssembler.getScope();
    FormatterOperand formatter = new FormatterOperand(qname, operand, parserAssembler.getScopeLocale());
    if (scope.getName().equals(QueryProgram.GLOBAL_SCOPE))
        parserAssembler.registerLocaleListener(formatter);
    {if (true) return formatter;}
      break;
    case FACT:
      jj_consume_token(FACT);
      jj_consume_token(LPAREN);
      name = Name();
      jj_consume_token(RPAREN);
    Operand factOperand = parserAssembler.findOperandByName(name);
    if (factOperand != null)
        {if (true) return new FactOperand(factOperand);}
    else
        {if (true) throw new ParseException("Operand " + name + " not found");}
      break;
    default:
      jj_la1[78] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Operand NamedExpression(String name, ParserAssembler parserAssembler) throws ParseException
  {
  Operand param1 = null;
  Operand param2 = null;
  List<OperandParam> operandParamList = null;
  QualifiedName qname;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case LBRACKET:
      param1 = IndexExpression(parserAssembler);
      if (jj_2_3(2)) 
      {
        param2 = IndexExpression(parserAssembler);
      } else 
      {
        ;
      }
    {if (true) return parserAssembler.newListVariableInstance(name, param1, param2);}
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case FACT:
      case LENGTH:
      case TERM:
      case CURRENCY:
      case FORMAT:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case NUMBER_LITERAL:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case UNKNOWN:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
      case 82:
        operandParamList = ArgumentList(parserAssembler, true);
        break;
      default:
        jj_la1[79] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
    qname = parserAssembler.getContextName(name);
    {if (true) return parserAssembler.getCallOperand(qname, operandParamList);}
      break;
    default:
      jj_la1[80] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Operand IndexExpression(ParserAssembler parserAssembler) throws ParseException
  {
  Operand param;
    jj_consume_token(LBRACKET);
    param = Expression(parserAssembler);
    jj_consume_token(RBRACKET);
    {if (true) return param;}
    throw new Error("Missing return statement in function");
  }

  final public List<OperandParam> ArgumentList(ParserAssembler parserAssembler, boolean nameRequired) throws ParseException
  {
  List<OperandParam> operandParamList = new ArrayList<OperandParam>();
  OperandParam operandParam;
  Token op;
    operandParam = Argument(parserAssembler, nameRequired);
    operandParamList.add(operandParam);
    label_28:
    while (true) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case COMMA:
        ;
        break;
      default:
        jj_la1[81] = jj_gen;
        break label_28;
      }
      op = jj_consume_token(COMMA);
      operandParam = Argument(parserAssembler, nameRequired);
      operandParamList.add(operandParam);
    }
    {if (true) return operandParamList;}
    throw new Error("Missing return statement in function");
  }

  final public OperandParam Argument(ParserAssembler parserAssembler, boolean nameRequired) throws ParseException
  {
    Token nameToken = null;
    VariableType varType = null;
    Operand operand = null;
    Operand expression;
    OperandMap operandMap = parserAssembler.getOperandMap();
    if (jj_2_4(2)) 
    {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
      {
      case INTEGER:
      case DOUBLE:
      case DECIMAL:
      case BOOLEAN:
      case STRING:
      case TERM:
      case CURRENCY:
        varType = Type(operandMap);
        break;
      default:
        jj_la1[82] = jj_gen;
        ;
      }
      nameToken = jj_consume_token(IDENTIFIER);
      jj_consume_token(ASSIGN);
    } else 
    {
      ;
    }
    expression = Expression(parserAssembler);
     String name = nameToken == null ? Term.ANONYMOUS : nameToken.image;
     if (nameRequired && name.isEmpty())
         name = expression.getName();
     if ((nameToken == null) ||(varType == null))
         {if (true) return new OperandParam(name, expression);}
     boolean isLiteral = !expression.isEmpty();
     if (varType != null)
         varType.setProperty(isLiteral ? VariableType.LITERAL : VariableType.EXPRESSION, expression);
     operand = varType.getInstance(parserAssembler, name);
     {if (true) return new OperandParam(name, operand);}
    throw new Error("Missing return statement in function");
  }

  final public Operand Literal() throws ParseException
  {
  Token lit;
  boolean flag;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER_LITERAL:
      lit = jj_consume_token(INTEGER_LITERAL);
    Long litValue = Long.decode(lit.image);
    {if (true) return new IntegerOperand(QualifiedName.ANONYMOUS, litValue);}
      break;
    case FLOATING_POINT_LITERAL:
      lit = jj_consume_token(FLOATING_POINT_LITERAL);
    {if (true) return new DoubleOperand(QualifiedName.ANONYMOUS, Double.valueOf(lit.image));}
      break;
    case STRING_LITERAL:
      lit = jj_consume_token(STRING_LITERAL);
    {if (true) return new StringOperand(QualifiedName.ANONYMOUS, getText(lit));}
      break;
    case TRUE:
    case FALSE:
      flag = BooleanLiteral();
    {if (true) return new BooleanOperand(QualifiedName.ANONYMOUS, flag);}
      break;
    case UNKNOWN:
      UnknownLiteral();
    Variable unknownLiteral = new Variable(QualifiedName.ANONYMOUS);
    unknownLiteral.assign(new Unknown());
    {if (true) return unknownLiteral;}
      break;
    default:
      jj_la1[83] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Parameter LiteralTerm() throws ParseException
  {
  Token lit;
  boolean flag;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case INTEGER_LITERAL:
      lit = jj_consume_token(INTEGER_LITERAL);
    {if (true) return new IntegerTerm(lit.image);}
      break;
    case FLOATING_POINT_LITERAL:
      lit = jj_consume_token(FLOATING_POINT_LITERAL);
    {if (true) return new DoubleTerm(lit.image);}
      break;
    case STRING_LITERAL:
      lit = jj_consume_token(STRING_LITERAL);
    {if (true) return new StringTerm(getText(lit));}
      break;
    case TRUE:
    case FALSE:
      flag = BooleanLiteral();
    {if (true) return new BooleanTerm(flag);}
      break;
    case UNKNOWN:
      UnknownLiteral();
    {if (true) return new Parameter(Term.ANONYMOUS, new Unknown());}
      break;
    default:
      jj_la1[84] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public boolean BooleanLiteral() throws ParseException
  {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) 
    {
    case TRUE:
      jj_consume_token(TRUE);
    {if (true) return true;}
      break;
    case FALSE:
      jj_consume_token(FALSE);
    {if (true) return false;}
      break;
    default:
      jj_la1[85] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void UnknownLiteral() throws ParseException
  {
    jj_consume_token(UNKNOWN);
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_3R_43() {
    if (jj_scan_token(CURRENCY)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_45()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_59() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_42() {
    if (jj_scan_token(TERM)) return true;
    return false;
  }

  private boolean jj_3R_80() {
    if (jj_scan_token(38)) return true;
    return false;
  }

  private boolean jj_3R_58() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_41() {
    if (jj_scan_token(DECIMAL)) return true;
    return false;
  }

  private boolean jj_3R_53() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_54()) {
    jj_scanpos = xsp;
    if (jj_3R_55()) {
    jj_scanpos = xsp;
    if (jj_3R_56()) {
    jj_scanpos = xsp;
    if (jj_3R_57()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_54() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_58()) {
    jj_scanpos = xsp;
    if (jj_3R_59()) {
    jj_scanpos = xsp;
    if (jj_3R_60()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_79() {
    if (jj_3R_81()) return true;
    return false;
  }

  private boolean jj_3R_40() {
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  private boolean jj_3R_36() {
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_49() {
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_78() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_66() {
    if (jj_3R_67()) return true;
    return false;
  }

  private boolean jj_3R_39() {
    if (jj_scan_token(DOUBLE)) return true;
    return false;
  }

  private boolean jj_3R_77() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_38() {
    if (jj_scan_token(BOOLEAN)) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_29()) return true;
    return false;
  }

  private boolean jj_3R_37() {
    if (jj_scan_token(INTEGER)) return true;
    return false;
  }

  private boolean jj_3R_35() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_37()) {
    jj_scanpos = xsp;
    if (jj_3R_38()) {
    jj_scanpos = xsp;
    if (jj_3R_39()) {
    jj_scanpos = xsp;
    if (jj_3R_40()) {
    jj_scanpos = xsp;
    if (jj_3R_41()) {
    jj_scanpos = xsp;
    if (jj_3R_42()) {
    jj_scanpos = xsp;
    if (jj_3R_43()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_76() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_75() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) {
    jj_scanpos = xsp;
    if (jj_3R_78()) {
    jj_scanpos = xsp;
    if (jj_3R_79()) {
    jj_scanpos = xsp;
    if (jj_3R_80()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_65() {
    if (jj_3R_66()) return true;
    return false;
  }

  private boolean jj_3R_32() {
    if (jj_3R_35()) return true;
    return false;
  }

  private boolean jj_3R_74() {
    if (jj_scan_token(FACT)) return true;
    return false;
  }

  private boolean jj_3R_48() {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3R_64() {
    if (jj_scan_token(BANG)) return true;
    return false;
  }

  private boolean jj_3R_63() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_64()) {
    jj_scanpos = xsp;
    if (jj_3R_65()) return true;
    }
    return false;
  }

  private boolean jj_3R_52() {
    if (jj_3R_53()) return true;
    return false;
  }

  private boolean jj_3R_34() {
    if (jj_3R_36()) return true;
    return false;
  }

  private boolean jj_3R_73() {
    if (jj_scan_token(FORMAT)) return true;
    return false;
  }

  private boolean jj_3R_62() {
    if (jj_scan_token(DECR)) return true;
    return false;
  }

  private boolean jj_3_4() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_32()) jj_scanpos = xsp;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_83() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  private boolean jj_3R_47() {
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_30()) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_72() {
    if (jj_scan_token(LENGTH)) return true;
    return false;
  }

  private boolean jj_3R_29() {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_61() {
    if (jj_scan_token(INCR)) return true;
    return false;
  }

  private boolean jj_3R_82() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  private boolean jj_3R_81() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_82()) {
    jj_scanpos = xsp;
    if (jj_3R_83()) return true;
    }
    return false;
  }

  private boolean jj_3R_71() {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_51() {
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_70() {
    if (jj_3R_30()) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_3R_31()) return true;
    return false;
  }

  private boolean jj_3R_57() {
    if (jj_3R_63()) return true;
    return false;
  }

  private boolean jj_3R_33() {
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3R_46() {
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3R_56() {
    if (jj_3R_62()) return true;
    return false;
  }

  private boolean jj_3R_69() {
    if (jj_scan_token(NUMBER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_30() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_33()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_55() {
    if (jj_3R_61()) return true;
    return false;
  }

  private boolean jj_3R_68() {
    if (jj_3R_75()) return true;
    return false;
  }

  private boolean jj_3R_67() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_68()) {
    jj_scanpos = xsp;
    if (jj_3R_69()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) {
    jj_scanpos = xsp;
    if (jj_3R_72()) {
    jj_scanpos = xsp;
    if (jj_3R_73()) {
    jj_scanpos = xsp;
    if (jj_3R_74()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_45() {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_50() {
    if (jj_3R_51()) return true;
    return false;
  }

  private boolean jj_3R_44() {
    if (jj_3R_46()) return true;
    return false;
  }

  private boolean jj_3R_60() {
    if (jj_scan_token(82)) return true;
    return false;
  }

  private boolean jj_3R_31() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_34()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public QueryParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[86];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static 
  {
    jj_la1_init_0();
    jj_la1_init_1();
    jj_la1_init_2();
  }
  private static void jj_la1_init_0() 
  {
    jj_la1_0 = new int[] { 0x6a7dfc0,0x6a7dfc0,0x6a75fc0,0x6a75fc0,0x0,0x0,0x0,0x0,0x6a65fc0,0x2040000,0x0,0x0,0x0,0x0,0x0,0xa007c0,0x0,0x25b81fc0,0x0,0x25b81fc0,0x0,0x0,0xa007c0,0x0,0x0,0xa007c0,0x0,0x0,0x0,0x0,0x0,0x2000,0x2000,0x0,0x0,0x0,0x25b817c0,0x0,0x800,0x21b807c0,0x21b807c0,0x0,0x21180000,0x0,0x21b807c0,0x0,0x0,0x0,0x0,0x0,0x8400000,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x21180000,0x21180000,0x0,0x0,0x0,0x21180000,0x21b807c0,0x0,0x0,0xa007c0,0x20000000,0x20000000,0x0, };
  }
  private static void jj_la1_init_1() 
  {
    jj_la1_1 = new int[] { 0x100,0x100,0x100,0x100,0x200,0x0,0x10000,0x200,0x100,0x0,0x100000,0x400000,0x200,0x108,0x200,0x0,0x10000,0xe0600b7b,0x10000,0xe0600b7b,0x200,0x10000,0x0,0x2000,0x40000,0x0,0x2000,0x0,0x440000,0x108,0x800,0x440000,0x440000,0x400000,0x400000,0x800,0xe0600b7b,0x10000,0x0,0xe020037b,0xe020037b,0x10000,0xe0200b7b,0x800,0xe020037b,0x10000,0x440200,0x10000,0x200,0x10000,0x200,0x10000,0x10000,0x10000,0x200,0xfb,0x20000,0x40000,0x40000,0x8000000,0x10000000,0x0,0x0,0x0,0x4800000,0x4800000,0x3180000,0x3180000,0x80000000,0x80000000,0x0,0x0,0x80000000,0xe020037b,0x20037b,0x60000000,0x60000000,0x2200,0x37b,0xe020037b,0x2200,0x10000,0x0,0x79,0x79,0x30, };
  }
  private static void jj_la1_init_2() 
  {
    jj_la1_2 = new int[] { 0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x70001,0x0,0x70001,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f80,0x17f80,0x0,0x0,0x17f80,0x17f80,0x10000,0x10000,0x0,0x50001,0x0,0x0,0x40001,0x40001,0x0,0x40001,0x0,0x40001,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f80,0x7f80,0x0,0x0,0x10,0x20,0x8,0x0,0x0,0x0,0x0,0x1,0x1,0x46,0x46,0x40001,0x40001,0x0,0x0,0x0,0x0,0x0,0x40001,0x0,0x0,0x0,0x0,0x0,0x0, };
  }
  final private JJCalls[] jj_2_rtns = new JJCalls[4];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public QueryParser(java.io.InputStream stream) 
  {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public QueryParser(java.io.InputStream stream, String encoding) 
  {
    try
    {
      jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
    }
    catch(java.io.UnsupportedEncodingException e)
    {
      throw new RuntimeException(e);
    }
    token_source = new QueryParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 86; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) 
   {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) 
  {
    try
    {
      jj_input_stream.ReInit(stream, encoding, 1, 1);
    }
    catch(java.io.UnsupportedEncodingException e)
    {
      throw new RuntimeException(e);
    }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 86; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public QueryParser(java.io.Reader stream) 
  {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new QueryParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 86; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) 
  {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 86; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
        jj_2_rtns[i]= new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public QueryParser(QueryParserTokenManager tm) 
  {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 86; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(QueryParserTokenManager tm) 
  {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 86; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException 
  {
    Token oldToken;
    if ((oldToken = token).next != null)
      token = token.next;
    else
      token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) 
    {
      jj_gen++;
      if (++jj_gc > 100) 
      {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) 
        {
          JJCalls c = jj_2_rtns[i];
          while (c != null) 
          {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) 
  {
    if (jj_scanpos == jj_lastpos) 
    {
      jj_la--;
      if (jj_scanpos.next == null) 
      {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else 
      {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else 
    {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) 
    {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() 
  {
    if (token.next != null)
      token = token.next;
    else
      token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) 
  {
    Token t = token;
    for (int i = 0; i < index; i++) 
    {
      if (t.next != null)
        t = t.next;
      else
        t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() 
  {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) 
  {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) 
    {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) 
    {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) 
    {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) 
      {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) 
        {
          for (int i = 0; i < jj_expentry.length; i++) 
          {
            if (oldentry[i] != jj_expentry[i]) 
            {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() 
  {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[83];
    if (jj_kind >= 0) 
    {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 86; i++) 
    {
      if (jj_la1[i] == jj_gen) 
      {
        for (int j = 0; j < 32; j++) 
        {
          if ((jj_la1_0[i] & (1<<j)) != 0) 
          {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) 
          {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) 
          {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 83; i++) 
    {
      if (la1tokens[i]) 
      {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) 
    {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() 
  {
  }

  /** Disable tracing. */
  final public void disable_tracing() 
  {
  }

  private void jj_rescan_token() 
  {
    jj_rescan = true;
    for (int i = 0; i < 4; i++) 
    {
    try 
      {
      JJCalls p = jj_2_rtns[i];
      do 
        {
        if (p.gen > jj_gen) 
          {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) 
            {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) 
  {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) 
    {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls 
  {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
